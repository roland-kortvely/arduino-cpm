                ;MOVCPM.ASM	BY DIGITAL RESEARCH
                ;DISASSEMBLED 3 DEC 84 RHP
                ;CONVERTED FOR DIGITAL RESEARCH 'MAC' 
                ;MACROASSEMBLER 7 DEC 84 RHP
                ;
 0100           	ORG	00100H
                ;
                ; EQUATES
                ;
 0000 =         WBOOT	EQU	00000H
 0005 =         BDOS	EQU	00005H		;BDOS JUMP ENTRY POINT
 0006 =         BDOSADR EQU	00006H		;ADDRESS OF BOTTOM OF BDOS
 005D =         FILNAM	EQU	0005DH		;START OF FILE NAME IN FCB1+1
 006D =         FCB2	EQU	0006DH		;START OF FCB 2 +1
 0800 =         STACK	EQU	00800H
 0900 =         CODEST	EQU	00900H		;START OF CPM CODE (BOOT)
 1200 =         SERNO	EQU	01200H		;LOCATION OF SER# IN THE CCP
 1700 =         CPMLG	EQU	01700H		;LENGTH OF CPM CODE
 0009 =         PRSTRG	EQU	009H
                ;
                ;PROGRAM START
                ;
 0100 C32C01    START:	JMP	BEGIN		;GO TO REAL START OF PROGRAM
                ;
                ;COPYRIGHT NOTICE
                ;
 0103 434F505952	DB	'COPYRIGHT (C) DIGITAL RESEARCH, 1979     '
                ;
 012C 310008    BEGIN:	LXI	SP,STACK	;SET STACK AT 800H
 012F 115D00    	LXI	D,FILNAM	;POINT AT FILE NAME  
 0132 1A        	LDAX	D 		;GET CHARACTER
 0133 FE20      	CPI	020H		;IS IT A SPACE?
 0135 CA9101    	JZ	RAMCHK
 0138 FE3F      	CPI	03FH		;IS IT A ? (WILDCARD)
 013A CA9101     	JZ	RAMCHK
                ;
                ;CHECK FOR 2 ASCII NUMBERS AND CONVERT TO HEX
                ;
 013D 210000    	LXI	H,00000H
 0140 1A        ASCHEX:	LDAX	D		;GET CHARACTER
 0141 13        	INX	D		;BUMP TO NEXT CHAR
 0142 FE20      	CPI	020H		;IS IT A SPACE?
 0144 CA5F01    	JZ	BADMM
 0147 B7        	ORA	A
 0148 CA5F01    	JZ	BADMM
 014B DE30      	SBI	030H		;NUMBER 0-9?
 014D FE0A      	CPI	00AH
 014F D27201    	JNC	PMSG1		;PRINT BAD MEMORY SIZE
                ;
                ;MULTIPLY HL BY 10
                ;
 0152 29        	DAD	H		;X2
 0153 E5        	PUSH	H		;SAVE X2
 0154 29        	DAD	H		;X4
 0155 29        	DAD	H		;X8
 0156 C1        	POP	B		;GET THE X2
 0157 09        	DAD	B		;X2+X8=X10
 0158 4F        	MOV	C,A		;SAVE CHAR IN C
 0159 0600      	MVI	B,000H		;CLEAR B TO ZERO
 015B 09        	DAD	B		;UPDATE HEX NO.
 015C C34001    	JMP	ASCHEX		;LOOP TIL DONE
                ;
 015F 7C        BADMM:	MOV	A,H
 0160 B7        	ORA	A
 0161 C27201    	JNZ	PMSG1		;PRINT BAD MEMORY SIZE
 0164 7D        	MOV	A,L
 0165 FE10      	CPI	010H
 0167 DA7201    	JC	PMSG1		;PRINT BAD MEMORY SIZE
 016A 2E00      	MVI	L,000H
 016C 67        	MOV	H,A
 016D 29        	DAD	H
 016E 29        	DAD	H
 016F C3A501    	JMP	SVHIRM
                ;
 0172 117B01    PMSG1:	LXI	D,MESSG1	;INVALID MEMORY SIZE
 0175 CD7503    	CALL	PRINT
 0178 C30000    	JMP	WBOOT
                ;
 017B 0D0A      MESSG1:	DB	00DH, 00AH
 017D 494E56414C	DB	'INVALID MEMORY SIZE$'
                ;
 0191 210000    RAMCHK:	LXI	H,00000H
 0194 24        RAMLUP:	INR	H
 0195 CAA101    	JZ	HIRAM
                ;
                ;SCAN MEMORY TO CHECK FOR RAM
                ;
 0198 7E        	MOV	A,M		;GET A CHARACTER
 0199 2F        	CMA			;INVERT IT
 019A 77        	MOV	M,A		;PUT IT BACK
 019B BE        	CMP	M		;SET Z FLAG IF = ELSE NOT RAM
 019C 2F        	CMA			;RIGHT SIDE UP
 019D 77        	MOV	M,A		;PUT IT BACK THE WAY IT WAS
 019E CA9401    	JZ	RAMLUP		;IF RAM, KEEP LOOKING
                ;
                ;IF HERE, THEN HL=END OF RAM
                ;
 01A1 7C        HIRAM:	MOV	A,H		;ROUND OFF HI RAM ADDR 
 01A2 E6FC      	ANI	0FCH		; TO NEAREST K
 01A4 67        	MOV	H,A
                ;
 01A5 E5        SVHIRM:	PUSH	H		;SAVE HI RAM ADDR ON STACK
                ;
 01A6 2A0600    	LHLD	BDOSADR		;MOVE BDOS ADDR TO STOR1
 01A9 227A03    	SHLD	STORE1    
 01AC E1        	POP	H		;GET HI RAM ADDR AGAIN
 01AD E5        	PUSH	H		;BUT LEAVE IT ON THE STACK TOO
 01AE 7C        	MOV	A,H		;GET HI BYTE OF RAM ADDR
 01AF 0F        	RRC			;CHANGE TO UNITS OF K
 01B0 0F        	RRC
 01B1 E63F      	ANI	03FH		;<64K?
 01B3 C2B801    	JNZ	SETMSZ		;SMALL ENOUGH
 01B6 3E40      	MVI	A,040H		;ELSE SET TO 64K
 01B8 47        SETMSZ:	MOV	B,A		;SAVE SIZE IN B
 01B9 218D03    	LXI	H,SCPMSZ	;POINT TO CPM SZ MSG
 01BC 3E30      	MVI	A,030H		;FILL WITH 00 ASCII  
 01BE 77        	MOV	M,A		;STORE 0
 01BF 23        	INX	H		;NEXT LOCATION
 01C0 77        	MOV	M,A		;STORE 0
 01C1 218E03    SIZLUP:	LXI	H,SECCHR	;POINT TO SECOND CHAR
 01C4 34        	INR	M		;INCREMENT MEMORY
 01C5 7E        	MOV	A,M		;READ THE CHAR
 01C6 FE3A      	CPI	03AH		;ASCII 9 OR LESS?
 01C8 DACF01    	JC	SZLP1
 01CB 3630      	MVI	M,030H		;SET TO ASCII 0
 01CD 2B        	DCX	H		;POINT TO HI CHAR
 01CE 34        	INR	M		;INCREMENT MEMORY
 01CF 05        SZLP1:	DCR	B		;HAS MEM SIZE IN K
 01D0 C2C101    	JNZ	SIZLUP
 01D3 117E03    	LXI	D,MESSG4	;POINT TO CONSTRUCTING CPM MSG
 01D6 CD7503    	CALL	PRINT		;PRINT CONSTRUCTING CPM MSG
                ;
 01D9 210108    	LXI	H,STACK+1	;POINT TO BOTTOM OF STACK
                ;
 01DC 4E        	MOV	C,M		;GET MEMORY SIZE IN BC
 01DD 23        	INX	H
 01DE 46        	MOV	B,M
                ;
 01DF C5        	PUSH	B		;PUT MEMORY SIZE ON TOP OF STACK
                ;
 01E0 210009    	LXI	H,CODEST	;POINT TO START OF CODE TO MOVE
 01E3 118F03    UPDCD:	LXI	D,SMALLK
                
 01E6 78        	MOV	A,B		;IS BC = 0?
 01E7 B1        	ORA	C		;WHERE BC = MEMORY SIZE
 01E8 CA2C02    	JZ	WHAT2		;IF SO GOTO WHAT2
                
 01EB 0B        	DCX	B		;DECREMENT MEM PTR
 01EC C5        	PUSH	B		;SAVE MEMORY POINTER
 01ED 0E0F      	MVI	C,00FH
 01EF E5        	PUSH	H		;SAVE CODE POINTER
 01F0 1A        NOT16:	LDAX	D
 01F1 BE        	CMP	M
 01F2 C21A02    	JNZ	INCOD
 01F5 13        	INX	D
 01F6 23        	INX	H
 01F7 0D        	DCR	C		;COUNT 16
 01F8 CA2002    	JZ	WHAT1
 01FB C3F001    	JMP	NOT16
                ;
 01FE 01        	DB	001H		;DUMMY BYTE
                ;
 01FF AF        SDELY:	XRA	A
 0200 3D        DELUP:	DCR	A		;SMALL DELAY HERE
 0201 C20002    	JNZ	DELUP
                ;
 0204 21F376    	LXI	H,076F3H	;LOAD STORE1 WITH F376H
 0207 227A03    	SHLD	STORE1    
                ;
 020A 217703    	LXI	H,CHCALL	;CHANGE INSTRUCTION TO CALL
 020D 36CD      	MVI	M,0CDH
                ;
 020F 118802    	LXI	D,ADRCH+1	;NOW POINTS TO CHSER
 0212 210500    	LXI	H,00005H	;POINT TO SYNCH ERROR MSG
 0215 19        	DAD	D		;NEW ADDRESS
 0216 EB        	XCHG			;PUT MSG PTR IN DE
 0217 C37503    	JMP	PRINT		;PRINT SYNCH ERROR MSG
                ;
 021A E1        INCOD:	POP	H
 021B 23        	INX	H
 021C C1        	POP	B
 021D C3E301    	JMP	UPDCD
                ;
 0220 E1        WHAT1:	POP	H
 0221 C1        	POP	B
 0222 2B        	DCX	H
 0223 118E03    	LXI	D,SECCHR
 0226 1A        	LDAX	D
 0227 77        	MOV	M,A
 0228 2B        	DCX	H
 0229 1B        	DCX	D
 022A 1A        	LDAX	D
 022B 77        	MOV	M,A
 022C 017A03    WHAT2:	LXI	B,STORE1
 022F 0A        	LDAX	B
 0230 FE06      	CPI	006H
 0232 3E00      	MVI	A,000H
 0234 C25A02    	JNZ	CHADR
 0237 02        	STAX	B
 0238 C1        	POP	B
 0239 E1        	POP	H
 023A C5        	PUSH	B
 023B 78        	MOV	A,B
 023C C603      	ADI	003H
 023E 47        	MOV	B,A
 023F 7D        	MOV	A,L
 0240 91        	SUB	C
 0241 6F        	MOV	L,A
 0242 7C        	MOV	A,H
 0243 98        	SBB	B
 0244 67        	MOV	H,A
 0245 227C03    	SHLD	STORE2    
 0248 EB        	XCHG	
 0249 210009    	LXI	H,CODEST
 024C C1        	POP	B
 024D C5        	PUSH	B
 024E 3A6D00    	LDA	FCB2
 0251 FE20      	CPI	020H
 0253 CA6302    	JZ	SHOVE
 0256 09        	DAD	B
 0257 C37002    	JMP	MOVDUN
                ;
 025A 21FF01    CHADR:	LXI	H,SDELY
 025D 220703    	SHLD	HANG+1    
 0260 C30603    	JMP	HANG
                ;
 0263 78        SHOVE:	MOV	A,B		;CHECK BYTES TO MOVE COUNT
 0264 B1        	ORA	C		;THROUGH YET?
 0265 CA7002    	JZ	MOVDUN		;DONE MOVING
 0268 0B        	DCX	B		;COUNT-1
 0269 7E        	MOV	A,M		;GET BYTE TO MOVE
 026A 12        	STAX	D		;POINT TO DESTINATION
 026B 13        	INX	D		;NEXT DEST.
 026C 23        	INX	H		;NEXT BYTE
 026D C36302    	JMP	SHOVE		;LOOP TIL DONE
                ;
 0270 C1        MOVDUN:	POP	B
 0271 E5        	PUSH	H
 0272 2A7C03    	LHLD	STORE2
 0275 EB        	XCHG	
 0276 210001    	LXI	H,START
 0279 19        	DAD	D
 027A 3A6D00    	LDA	FCB2
 027D FE20      	CPI	020H
 027F CA8502    	JZ	RLCLP
 0282 110009    	LXI	D,CODEST
 0285 78        RLCLP:	MOV	A,B		;CHECK BIT COUNTR 
 0286 B1        	ORA	C		;RLOC DONE?
 0287 CAC002    ADRCH:	JZ	CHSER
 028A C3A402    	JMP	MOREL
                ;
 028D 0D0A      MESSG2:	DB	00DH, 00AH
 028F 53594E4352	DB	'SYNCRONIZATION ERROR$'
                ;
 02A4 0B        MOREL:	DCX	B		;DROP THE BYTE COUNT
 02A5 7B        	MOV	A,E		;IS DE ADDR MOD 8 BYTES?
 02A6 E607      	ANI	007H		;IF SO NEED NEXT BIT MAP BYTE
 02A8 C2B002    	JNZ	SAMBYT		;STILL ON SAM BIT MAP BYTE
                ;
                ;GET NEXT MAP BYTE VIA POINTER ON STACK
                ;
 02AB E3        	XTHL			;SAVE HL & GET MAP PTR
 02AC 7E        	MOV	A,M		;GET MAP BYTE
 02AD 23        	INX	H		;POINT TO NEXT BYTE
 02AE E3        	XTHL			;REPLACE POINTER ON STACK
 02AF 6F        	MOV	L,A		;MAP BYTE TO HOLDINO REG.
                ;
 02B0 7D        SAMBYT:	MOV	A,L		;GET CURRENT BIT MAP BYTE
 02B1 17        	RAL			;SHIFT ONE BIT
 02B2 6F        	MOV	L,A		;SAVE FOR NEXT PASS
 02B3 D2BC02    	JNC	NOFFST	;0=NO OFFSET NEEDED
 02B6 1A        	LDAX	D		;GET DEST BYTE
 02B7 84        	ADD	H		;ADD THE OFFSET
 02B8 12        	STAX	D		;PUT IT BACK
 02B9 C3BC02    	JMP	NOFFST		;
                ;
 02BC 13        NOFFST:	INX	D		;BUMP MOVED CODE BYTE COUNTER
 02BD C38502    	JMP	RLCLP		;BACK FOR MORE BYTES
                ;
                ;MATCH SERIAL NO OF MOVCPM AND CCP
                ;
 02C0 D1        CHSER:	POP	D		;CLEAN UP STACK
 02C1 110012    	LXI	D,SERNO		;POINT TO SER NO IN CCP
 02C4 2A7A03    	LHLD	STORE1		;GET LOCAL SER NO
 02C7 0E06      	MVI	C,006H		;CHECK 6 CHAR OF SERIAL NO.
 02C9 1A        LOOP6:	LDAX	D		;GET CHAR OF SER NO
 02CA BE        	CMP	M		;COMPARE LOCAL SER NO
 02CB C25A02    	JNZ	CHADR		;NO MATCH CHANGE THE JUMP ADDR
 02CE 23        	INX	H		;NEXT CHAR LOC
 02CF 13        	INX	D		;NEXT CHAR CCP
 02D0 0D        	DCR	C		;EXT CHAR COUNT
 02D1 C2C902    	JNZ	LOOP6		;IF C <> 0 THEN KEEP LOOPING
                ;
                ;HERE IMPLIES MATCHED SERIAL NUMBERS
                ;
 02D4 3A6D00    	LDA	FCB2	;GET CHAR FROM FILE CONT BLK 2
 02D7 FE20      	CPI	020H		;IS IT A SPACE?
 02D9 CA6D03    	JZ	CBOOT		;YEAH, GOTO CBOOT
 02DC 0680      	MVI	B,080H		;SET COUNTER
 02DE 210009    	LXI	H,CODEST	;POINT TO CODE START ADDR
 02E1 7E        MOVLUP:	MOV	A,M		;GET A CHAR OF CODE
 02E2 B7        	ORA	A		;SET FLAGS
 02E3 C20903    	JNZ	BINDEC		;SOMETHING THERE
 02E6 23        	INX	H		;TRY NEXT ADDR
 02E7 05        	DCR	B		;COUNT DOWN
 02E8 C2E102    	JNZ	MOVLUP		;STILL COUNTING, THEN LOOP
 02EB EB        	XCHG	
 02EC 2A0108    	LHLD	STACK+1		;LOAD HL WITH ADDR OF ?
 02EF 0180FF    	LXI	B,0FF80H	;LOAD BC WITH 80FFH
 02F2 09        	DAD	B
 02F3 44        	MOV	B,H		;PUT HL IN BC
 02F4 4D        	MOV	C,L
 02F5 210009    	LXI	H,CODEST	;POINT TO START OF CODE
 02F8 78        MVBYT:	MOV	A,B		;CHK BYTE CNT
 02F9 B1        	ORA	C		;ALL MOVED YET?
 02FA CA0903    	JZ	BINDEC
 02FD 0B        	DCX	B		;DEC BYTES TO MOVE CNT
 02FE 1A        	LDAX	D		;READ FROM DE
 02FF 77        	MOV	M,A		;PLACE IN HL
 0300 13        	INX	D		;NEXT DE
 0301 23        	INX	H		;NEXT HL
 0302 C3F802    	JMP	MVBYT		;LOOP TIL DONE
                ;
 0305 01        	DB	001H		;DUMMY BYTE
                ;
 0306 C30603    HANG:	JMP	HANG		;OR JUMP A01FF
                ;
 0309 210108    BINDEC:	LXI	H,STACK+1	;LOAD BC FROM TOP OF STACK
                ;
 030C 4E        	MOV	C,M		;LOAD BC FROM BOTTOM OF STACK
 030D 23        	INX	H
 030E 46        	MOV	B,M
                ;
 030F 210009    	LXI	H,CODEST	;POINT TO CODE START
 0312 09        	DAD	B		;CALCULATE MEMORY SIZE
 0313 44        	MOV	B,H		;UPDATE MSIZE IN K
 0314 215F03    	LXI	H,SIZE1	;POINT TO 1ST CHAR OF SIZE
 0317 3E30      	MVI	A,030H		;LOAD ASCII 0
 0319 77        	MOV	M,A		;LOAD IT IN 1ST CHAR
 031A 23        	INX	H		;POINT TO 2ND CHAR
 031B 77        	MOV	M,A		;A ZERO THERE TOO
 031C 05        NUMLUP:	DCR	B		;DECR MEMORY SIZE IN K
 031D CA3103    	JZ	PTSIZ
 0320 216003    	LXI	H,SIZE2	;POINT TO SECOND CHAR
 0323 34        	INR	M		;INCR THE VALUE THERE
 0324 7E        	MOV	A,M		;GET THE VALUE
 0325 FE3A      	CPI	03AH		;IS IT OVER 9?
 0327 DA1C03    	JC	NUMLUP	;ELSE LOOP TO INCREASE
 032A 3630      	MVI	M,030H	;OR BACK TO 0 & BUMP 1ST#
 032C 2B        	DCX	H		;POINT TO 1ST
 032D 34        	INR	M		;BUMP IT 10K
 032E C31C03    	JMP	NUMLUP		;BACK TO 1K LOOP
                ;
 0331 2A8D03    PTSIZ:	LHLD	SCPMSZ		;POINT TO CPM SIZE
 0334 226503    	SHLD	CPMSZ    	;GET IT
 0337 114003    	LXI	D,MESSG3	;POINT TO SYSGEN MSG
 033A CD7503    	CALL	PRINT		;PRINT SYSGEN MESSAGE
 033D C30000    	JMP	WBOOT
                ;
 0340 0D0A      MESSG3:	DB	00DH, 00AH
 0342 5245414459	DB	'READY FOR "SYSGEN" OR'
 0357 0D0A      	DB	00DH, 00AH
 0359 2253415645	DB	'"SAVE '
 035F 30        SIZE1:	DB	'0'
 0360 30        SIZE2:	DB	'0'
 0361 2043504D  	DB	' CPM'
 0365 3030      CPMSZ:	DB	'00'
 0367 2E434F4D22	DB	'.COM"$'
                ;
 036D 110017    CBOOT:	LXI	D,CPMLG		;LOAD THE LENGTH OF CPM
 0370 2A7C03    	LHLD	STORE2		;GET THE LOCATION OF CPM
 0373 19        	DAD	D		;CALC THE START OF BIOS 
 0374 E9        	PCHL			;JUMP TO COLD BOOT
                ;
 0375 0E09      PRINT:	MVI	C,PRSTRG	;PREPARE TO PRINT A STRING
 0377 C30500    CHCALL:	JMP	BDOS		; GO DO IT
                ;
 037A 00        STORE1:	NOP
 037B 00        	NOP
                ;
 037C 00        STORE2:	NOP
 037D 00        	NOP
                ;
 037E 0D0A      MESSG4:	DB	00DH, 00AH
 0380 434F4E5354	DB	'CONSTRUCTING '
 038D 30        SCPMSZ:	DB	'0' 
 038E 30        SECCHR:	DB	'0' 
 038F 6B        SMALLK:	DB	'k' 
 0390 2043502F4D	DB	' CP/M vers 2.2$'
                ;
 039F           	END
